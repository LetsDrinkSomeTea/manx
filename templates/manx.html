<meta id="websocket-data" data-websocket="{{ websocket }}">

<script src="/manx/js/xterm.js"></script>
<!--<script type="module" src="/manx/js/terminal.js"></script>-->
<link rel="stylesheet" href="/manx/css/basic.css">
<link rel="stylesheet" href="/manx/css/xterm.css"/>

<div x-data="alpineManx()" x-init="initPage(); $watch('selectedSessionInfo', () => resetFields())">
    <div x-ref="header">
        <h2>Manx</h2>
        <p class="has-text-weight-bold">
            A coordinated access trojan (CAT)
        </p>
        <p>
            The Manx agent, written in GoLang, connects to the server over the TCP <i>contact point</i>.
            This raw TCP socket connection allows Manx to keep a persistent connection between host-and-server.
            Bundled with Manx is a reverse-shell management tool, called the <i>terminal</i>
            - below - which allows you to establish a local shell on an agent.
        </p>
        <p class="has-text-weight-bold">
            To deploy a Manx agent, go to the Agents tab.
        </p>
    </div>
    <hr>
    <div class="is-flex is-flex-direction-column">
        <h3>Terminal</h3>
        <div class="is-flex is-flex-direction-row is-justify-content-space-around">
            <!--                    <table class="ability-filter" frame=void rules=rows style="border-spacing:5px;width:100%">-->
            <div class="select is-small">
                <select x-model="selectedSessionInfo"
                        x-on:change="getTactics(); getShellHistory(this);">
                    <!--                                //;clearTerminal();">-->
                    <option value="" disabled selected>Select a session</option>
                    <template x-for="s in sessions" :key="s.id">
                        <option x-bind:value="s.info" x-bind:data-paw="s.info"
                                x-bind:data-platform="s.platform"
                                x-bind:data-executor="s.executors[0]"
                                x-text="s.id + ' - ' + s.info"></option>
                    </template>
                </select>
            </div>
            <div class="select is-small">
                <select x-model="selectedTacticName" id="tactic-filter" x-on:change="getTechniques()">
                    <option value="" disabled selected>Select a tactic</option>
                    <template x-for="a in tactics" :key="a.ability_id">
                        <option x-text="a.tactic"></option>
                    </template>
                </select>
            </div>
            <div class="select is-small">
                <select x-model="selectedTechniqueID" x-on:change="getProcedures()">
                    <option value="" disabled selected>Select a technique</option>
                    <template x-for="t in techniques" :key="t.technique_id">
                        <option x-bind:value="t.technique_id"
                                x-text="t.technique_id + ' | ' + t.technique_name"></option>
                    </template>
                </select>
            </div>
            <div class="select is-small">
                <select x-model="selectedProcedureID" x-on:change="getProcedure()">
                    <option value="" disabled selected>Select a procedure</option>
                    <template x-for="p in procedures">
                        <option x-text="p.name" x-bind:value="p.ability_id"></option>
                    </template>
                </select>
            </div>
        </div>
        <br>
        <div x-text="terminalCommand" id="xterminal"></div>
    </div>
</div>

<script>
    // const { Terminal } = require('../static/js/terminal');

    function alpineManx() {
        return {
            sessions: JSON.parse('{{ sessions | tojson }}'),
            tactics: [],
            techniques: [],
            procedures: [],
            selectedSessionInfo: '',
            selectedTacticName: '',
            selectedTechniqueID: '',
            selectedProcedureID: '',
            terminalCommand: '',

            get sessionIDs() {
                return this.sessions ? this.sessions.flatMap((s) => s.info) : [];
            },

            get selectedSession() {
                return this.sessions ? this.sessions.find((s) => s.info === this.selectedSessionInfo) : '';
            },

            async initPage() {
                while (this.$refs.header) {
                    await sleep(3000);
                    this.refreshManx();
                }
            },

            refreshManx() {
                apiV2('POST', '/plugin/manx/sessions').then((sessions) => {
                    this.sessions = this.sessions.concat(sessions.filter((s) => !this.sessionIDs.includes(s.info)));
                }).catch((error) => {
                    toast('Error refreshing manx', false);
                    console.error(error);
                });
            },

            resetFields() {
                this.selectedTacticName = '';
                this.selectedTechniqueID = '';
                this.selectedProcedureID = '';
            },

            getShellHistory() {
                function populateHistory() {
                }

                restRequest('POST', { paw: this.selectedSession.paw }, populateHistory, '/plugin/manx/history');
            },

            getTactics() {
                const getUniqueAbilities = (self, data) => {
                    if (data.abilities) {
                        const seen = [];
                        self.tactics = data.abilities.filter((a) => {
                            if (!seen.includes(a.tactic)) {
                                seen.push(a.tactic);
                                return true;
                            }
                            return false;
                        });
                    }
                };

                restRequest('POST', { paw: this.selectedSessionInfo }, (data) => {
                    getUniqueAbilities(this, data);
                }, '/plugin/manx/ability');
            },

            getTechniques() {
                this.selectedTechniqueID = '';
                this.selectedProcedureID = '';

                let seenIDs = [];
                this.techniques = this.tactics.filter((a) => {
                    if (a.tactic === this.selectedTacticName && !seenIDs.includes(a.technique_id)) {
                        seenIDs.push(a.technique_id);
                        return true;
                    }
                    return false;
                });
            },

            getProcedures() {
                this.selectedProcedureID = '';

                this.procedures = this.techniques.filter((t) => t.technique_id === this.selectedTechniqueID);
            },

            getProcedure() {
                restRequest('POST', {
                    index: 'abilities',
                    ability_id: this.selectedProcedureID
                }, (self, data) => {
                    data = JSON.parse(`{"0":${data}}`);
                    console.log('data', typeof data);
                    console.log(data);
                    self.terminalCommand = data[0].forEach((ability) => {
                        ability.executors.find((e) => {
                            const session = self.selectedSession;
                            if (e.platform === session.platform && e.name === session.executors[0]) {
                                return e.command;
                            } return '';
                        });
                    });
                });
            }
        };
    }

    // const term = new Terminal();

    // # sourceURL=manx.js
</script>
